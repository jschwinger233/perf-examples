#define PAGE_SIZE (1<<12)
#define KASAN_STACK_ORDER 0
#define THREAD_SIZE_ORDER (2 + KASAN_STACK_ORDER)
#define THREAD_SIZE  ((uint64)(PAGE_SIZE << THREAD_SIZE_ORDER))
#define TOP_OF_KERNEL_STACK_PADDING ((uint64)0)

struct PyTypeObject {
    char _[24];
    char *tp_name;
}
struct PyObject {
    char _[8];
    struct PyTypeObject *ob_type;
}
struct PyVarObject {
    struct PyObject ob_base;
    char _[8];
}

struct _PyStr {
    char _[48];
    char buf[48];
}
struct PyCodeObject {
    char _[104];
    struct _PyStr *co_filename;
    struct _PyStr *co_name;
}

struct PyFrameObject {
    struct PyVarObject ob_base;
    struct PyFrameObject *f_back;
    struct PyCodeObject *f_code;
}

struct PyThreadState {
    char _[24];
    struct PyFrameObject *frame;
}

profile:hz:99 /pid == $1/
{
    $rsp = reg("sp");
    $rip = reg("ip");

    // kernel mode
    if (!(reg("cs") & 3)) {
        $task = (struct task_struct *)curtask;
        $__ptr = (uint64)$task->stack;
        $__ptr += THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING;
        $pt_regs = ((struct pt_regs *)$__ptr) - 1;
        $rsp = $pt_regs->sp;
        $rip = $pt_regs->ip;
    }

    $frame = (struct PyFrameObject *)0;

    $i = (uint64)0;
    $sp = (uint64)$rsp;
    while ($i <= 200) {
        $frame = *(struct PyFrameObject**)($sp + 8*$i);
        if (str($frame->ob_base.ob_base.ob_type->tp_name, 5) == "frame") {
            break;
        }
        $frame = (struct PyFrameObject *)0;
        $i += 1;
    }

    if ($frame == 0) {
        //printf("not found ip=%llx %s user=%d\n", $rip, usym($rip), !!(reg("cs") & 3));
        return;
    }

    printf("\n");
    $i = 0;
    while ($i < 20) {
        printf("%s:%s\n", $frame->f_code->co_filename->buf, $frame->f_code->co_name->buf);
        $i += 1;
        $frame = $frame->f_back;
        if ($frame == 0) {
            return;
        }
    }
}
